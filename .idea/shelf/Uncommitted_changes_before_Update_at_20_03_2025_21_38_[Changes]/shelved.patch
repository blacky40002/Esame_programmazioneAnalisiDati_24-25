Index: hotel.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from stanze import *\nfrom classi import Data, Prenotazione\n\"\"\"\nDefinire una classe Hotel che rappresenta un hotel.\n#STATO:\n- stanze: dizionario con chiave il numero della stanza e valore l'oggetto stanza.\n- prenotazioni: dizionario con chiave un intero e valore l'oggetto prenotazione.\n- id_prenotazioni: intero progressivo inizializzato a 1 e incrementato ogni volta che una prenotazione viene aggiunta, da usare come chiave per le prenotazioni.\n#METODI:\n- Costruttore che inizializza le variabili di istanza. Esempio di utilizzo: h = Hotel()\n- Metodo per il confronto di uguaglianza profonda tra due hotel.\n- Metodo per la rappresentazione in forma di stringa dell'hotel. Rispettando il formato di esempio: \"Hotel: 3 stanze (101,102,103), 2 prenotazioni.\" (Nota: non è necessario stampare i dettagli delle stanze e delle prenotazioni).\n- Metodi specificati in seguito.\n\"\"\"\n\n\"\"\"\nInserisce una nuova stanza nell'hotel.\n:param stanza oggetto di tipo Stanza da aggiungere all'hotel\n:raise TypeError: se i parametri non hanno il tipo corretto\n:raise ValueError: se i parametri non sono nel range di valori ammessi\n\"\"\"      \nclass Hotel:\n    def __init__(self):\n        self.stanze = {}\n        self.prenotazioni = {}\n        self.id_prenotazioni = 1\n\n    def __eq__(self, other):\n        return self.stanze == other.stanze and self.prenotazioni == other.prenotazioni and self.id_prenotazioni == other.id_prenotazioni\n\n    def __str__(self):\n        return f\"Hotel: {len(self.stanze)} stanze, {len(self.prenotazioni)} prenotazioni.\"\n    \ndef aggiungi_stanza(self, stanza):\n    if type(stanza) != Stanza:\n        raise TypeError(\"La stanza deve essere un oggetto di tipo Stanza\")\n    if stanza.get_numero_stanza() in self.stanze:\n        raise ValueError(\"La stanza è già presente nell'hotel\")\n    self.stanze[stanza.get_numero_stanza()] = stanza\n\n\n\"\"\"\nPrenota una stanza nell'hotel e incrementa id_prenotazioni se la prenotazione va a buon fine.\nCrea un oggetto Prenotazione con id_prenotazioni e i parametri in ingresso, e lo aggiunge al dizionario delle prenotazioni.\n:param numero_stanza: numero della stanza da prenotare\n:param data_arrivo: oggetto di tipo Data rappresentante la data di arrivo\n:param data_partenza: oggetto di tipo Data rappresentante la data di partenza\n:param nome_cliente: stringa rappresentante il nome del cliente\n:param numero_persone: intero rappresentante il numero di persone\n:return indice della prenotazione\n:raise TypeError: se i parametri non hanno il tipo corretto\n:raise ValueError: se la stanza è già occupata nelle date indicate\n:raise KeyError: se la stanza non è presente nell'hotel\n\"\"\"\ndef prenota(self, numero_stanza, data_arrivo, data_partenza, nome_cliente, numero_persone):\n    if type(data_arrivo) != Data or type(data_partenza) != Data:\n        raise TypeError(\"Le date devono essere oggetti di tipo Data\")\n    if type(nome_cliente) != str:\n        raise TypeError(\"Il nome del cliente deve essere una stringa\")\n    if type(numero_persone) != int:\n        raise TypeError(\"Il numero di persone deve essere un intero\")\n    if numero_stanza not in self.stanze:\n        raise KeyError(\"La stanza non è presente nell'hotel\")\n    for prenotazione in self.prenotazioni.values():\n        if prenotazione.get_numero_stanza() == numero_stanza:\n            if data_arrivo < prenotazione.get_data_partenza() and data_partenza > prenotazione.get_data_arrivo():\n                raise ValueError(\"La stanza è già occupata nelle date indicate\")\n    prenotazione = Prenotazione(self.id_prenotazioni, numero_stanza, data_arrivo, data_partenza, nome_cliente, numero_persone)\n    self.prenotazioni[self.id_prenotazioni] = prenotazione\n    self.id_prenotazioni += 1\n    return self.id_prenotazioni - 1\n\n\"\"\"\nDisdice una prenotazione dell'hotel.\n:param indice della prenotazione da disdire\n:raise KeyError: se la prenotazione non è presente nell'hotel\n\"\"\"    \ndef disdici(self, indice):\n    if indice not in self.prenotazioni:\n        raise KeyError(\"La prenotazione non è presente nell'hotel\")\n    del self.prenotazioni[indice]\n\n\"\"\"\nRimuove una stanza dall'hotel e tutte le prenotazioni relative a quella stanza.\n:param numero_stanza: numero della stanza da rimuovere\n:raise KeyError: se la stanza non è presente nell'hotel\n\"\"\"\ndef rimuovi_stanza(self, numero_stanza):\n    if numero_stanza not in self.stanze:\n        raise KeyError(\"La stanza non è presente nell'hotel\")\n    for prenotazione in list(self.prenotazioni.values()):\n        if prenotazione.get_numero_stanza() == numero_stanza:\n            del self.prenotazioni[prenotazione.get_id()]\n\n    del self.stanze[numero_stanza]\n\n\"\"\"\nRestituisce una stanza specifica dell'hotel.\n:param numero_stanza: numero della stanza da restituire\n:return: la stanza con numero_stanza\n:raise KeyError: se la stanza non è presente nell'hotel\n\"\"\"\ndef get_stanza(self, numero_stanza):\n    if numero_stanza not in self.stanze:\n        raise KeyError(\"La stanza non è presente nell'hotel\")\n    return self.stanze[numero_stanza]\n\n\"\"\"\nRestituisce la lista delle stanze presenti nell'hotel.\n:return: la lista delle stanze presenti nell'hotel\n\"\"\"\ndef get_stanze(self):\n    return list(self.stanze.values())\n\n\"\"\"\nRestituisce la lista delle stanze per tipo passato presenti nell'hotel.\n:param tipo: stringa rappresentante il tipo di stanza da cercare\n:return: la lista delle stanze per tipo passato presenti nell'hotel\n\"\"\"\ndef get_stanze_tipo(self, tipo):\n    return [stanza for stanza in self.stanze.values() if stanza.get_tipo_stanza() == tipo]\n\n\"\"\"\nRestituisce la lista delle prenotazioni presenti nell'hotel.\n:return: la lista delle prenotazioni presenti nell'hotel\n\"\"\"\ndef get_prenotazioni(self):\n    return list(self.prenotazioni.values())\n\n\"\"\"\nRestituisce una prenotazione specifica dell'hotel.\n:param indice: indice della prenotazione da restituire\n:return: la prenotazione con indice\n:raise KeyError: se la prenotazione non è presente nell'hotel\n\"\"\"\ndef get_prenotazione(self, indice):\n    return self.prenotazioni[indice]\n\n\"\"\"\nRestituisce la lista delle prenotazioni presenti nell'hotel in una data specifica.\n:param data: data da cercare\n:return: la lista delle prenotazioni presenti nell'hotel in una data specifica\n:raise TypeError: se data non è un oggetto di tipo Data\n\"\"\"\ndef get_prenotazioni_data(self, data):\n    return [prenotazione for prenotazione in self.prenotazioni.values() if prenotazione.get_data_arrivo() <= data and prenotazione.get_data_partenza() >= data]\n\n\"\"\"\nRestituisce il prezzo di una prenotazione specifica ottenuto dal prezzo della stanza per il numero di persone.\n:param indice: indice della prenotazione da cercare\n:return: il prezzo della prenotazione con indice\n:raise KeyError: se la prenotazione non è presente nell'hotel\n\"\"\"\ndef prezzo_prenotazione(self, indice):\n    return self.prenotazioni[indice].get_stanza().calcola_prezzo(self.prenotazioni[indice].get_numero_persone())\n\n\"\"\"\nRestituisce la lista delle prenotazioni presenti nell'hotel per un cliente specifico.\n:param cliente: nome del cliente da cercare\n:return: la lista delle prenotazioni presenti nell'hotel per un cliente specifico\n\"\"\"\ndef get_prenotazioni_cliente(self, cliente):\n    return [prenotazione for prenotazione in self.prenotazioni.values() if prenotazione.get_nome_cliente() == cliente]\n\n\n\"\"\"\nRestituisce la lista delle stanze libere nell'hotel in una data specifica.\n:param data: data da cercare\n:return: la lista delle stanze libere nell'hotel in una data specifica\n:raise TypeError: se data non è un oggetto di tipo Data\n\"\"\"\ndef get_stanze_libere(self, data):\n    data = Data(data.get_giorno(), data.get_mese(), data.get_anno())\n    if type(data) != Data:\n        raise TypeError(\"La data deve essere un oggetto di tipo Data\")\n    stanze_libere = []\n    for stanza in self.stanze.values():\n        occupata = False\n        for prenotazione in self.prenotazioni.values():\n            if prenotazione.get_numero_stanza() == stanza.get_numero_stanza():\n                if prenotazione.get_data_arrivo() <= data and prenotazione.get_data_partenza() >= data:\n                    occupata = True\n        if not occupata:\n            stanze_libere.append(stanza)\n    return stanze_libere\n\n    \n\n\"\"\"\nRestituisce la lista delle prenotazioni presenti nell'hotel per un tipo di stanza specifico.\n:param tipo_stanza: stringa rappresentante il tipo di stanza da cercare\n:return: la lista delle prenotazioni presenti nell'hotel per un tipo di stanza specifico\n\"\"\"\ndef get_prenotazioni_tipo_stanza(self, tipo_stanza):\n    tipo_stanza = tipo_stanza.capitalize()\n    return [prenotazione for prenotazione in self.prenotazioni.values() if prenotazione.get_stanza().get_tipo_stanza() == tipo_stanza]\n\n\"\"\"\nRestituisce la lista delle stanze dell'hotel sopra un prezzo specifico fra due date.\n:param numero_notti: numero di notti da considerare\n:param prezzo: prezzo da confrontare\n:return: la lista delle stanze dell'hotel sopra un prezzo specifico\n\"\"\"    \ndef get_stanze_sopra_prezzo(self, numero_notti, prezzo):\n    numero_notti = int(numero_notti)\n    prezzo = float(prezzo)\n    if type(numero_notti) != int:\n        raise TypeError(\"Il numero di notti deve essere un intero\")\n    if type(prezzo) != float:\n        raise TypeError(\"Il prezzo deve essere un numero con virgola\")\n    if prezzo <= 1:\n        raise ValueError(\"Il prezzo deve essere maggiore di 1\")\n    stanze_sopra_prezzo = []\n    for stanza in self.stanze.values():\n        if stanza.calcola_prezzo(numero_notti) > prezzo:\n            stanze_sopra_prezzo.append(stanza)\n    return stanze_sopra_prezzo\n\n\"\"\"\nRestituisce il numero totale di persone presenti nell'hotel in una data specifica.\n:param data: data da cercare\n:return: il numero totale di persone presenti nell'hotel in una data specifica\n:raise TypeError: se data non è un oggetto di tipo Data\n\"\"\"    \ndef get_numero_persone_data(self, data):\n    data = Data(data.get_giorno(), data.get_mese(), data.get_anno())\n    if type(data) != Data:\n        raise TypeError(\"La data deve essere un oggetto di tipo Data\")\n    persone_presenti = 0\n    for prenotazione in self.prenotazioni.values():\n        if prenotazione.get_data_arrivo() <= data and prenotazione.get_data_partenza() >= data:\n            persone_presenti += prenotazione.get_numero_persone()\n    return persone_presenti\n\n\"\"\"\nSalva lo stato dell'hotel su un file. Le eccezioni non devono essere gestite in questo metodo.\n:param nomefile: nome del file su cui salvare lo stato dell'hotel\n\"\"\"\ndef salva(self, nomefile):\n    with open(nomefile, 'w') as file:\n        file.write(\"Hotel\\n\")\n        for stanza in self.stanze.values():\n            file.write(f\"{stanza.get_numero_stanza()},{stanza.get_posti()},{stanza.get_prezzo_base()}\\n\")\n        for prenotazione in self.prenotazioni.values():\n            file.write(f\"{prenotazione.get_id()},{prenotazione.get_numero_stanza()},{prenotazione.get_data_arrivo()},{prenotazione.get_data_partenza()},{prenotazione.get_nome_cliente()},{prenotazione.get_numero_persone()}\\n\")\n\n\"\"\"\nCarica lo stato dell'hotel da un file e sostituisce lo stato corrente se il caricamento va a buon fine. Le eccezioni non devono essere gestite in questo metodo.\n:param nomefile: nome del file da cui caricare lo stato dell'hotel\n:raise ValueError: se il file non è nel formato corretto (es. se non è presente il nome dell'hotel)\n\"\"\"\ndef carica(self, nomefile):\n    with open(nomefile, 'r') as file:\n        righe = file.readlines()\n        if righe[0].strip() != \"Hotel\":\n            raise ValueError(\"Il file non è nel formato corretto\")\n        self.stanze = {}\n        self.prenotazioni = {}\n        self.id_prenotazioni = 1\n        for riga in righe[1:]:\n            dati = riga.strip().split(\",\")\n            if len(dati) == 3:\n                stanza = Stanza(int(dati[0]), int(dati[1]), float(dati[2]))\n                self.stanze[int(dati[0])] = stanza\n            elif len(dati) == 6:\n                prenotazione = Prenotazione(int(dati[0]), int(dati[1]), Data.from_string(dati[2]), Data.from_string(dati[3]), dati[4], int(dati[5]))\n                self.prenotazioni[int(dati[0])] = prenotazione\n                if int(dati[0]) >= self.id_prenotazioni:\n                    self.id_prenotazioni = int(dati[0]) + 1\n    
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hotel.py b/hotel.py
--- a/hotel.py	(revision 13001318b67badd3fa753e4ca9561cce0f3c607b)
+++ b/hotel.py	(date 1742387112497)
@@ -23,7 +23,7 @@
     def __init__(self):
         self.stanze = {}
         self.prenotazioni = {}
-        self.id_prenotazioni = 1
+        self.id_prenotazioni = 1 #se inizializziamo ogni volta ad un l'id
 
     def __eq__(self, other):
         return self.stanze == other.stanze and self.prenotazioni == other.prenotazioni and self.id_prenotazioni == other.id_prenotazioni
@@ -54,7 +54,7 @@
 """
 def prenota(self, numero_stanza, data_arrivo, data_partenza, nome_cliente, numero_persone):
     if type(data_arrivo) != Data or type(data_partenza) != Data:
-        raise TypeError("Le date devono essere oggetti di tipo Data")
+        raise TypeError("Le date devono essere oggetti di tipo Data")   #todo qui uguale possiamo fare una funzione dove le passiamo il valore e il tipo che vogliamo cotrollare senza farlo a mano ogni volta
     if type(nome_cliente) != str:
         raise TypeError("Il nome del cliente deve essere una stringa")
     if type(numero_persone) != int:
Index: classi.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nDefinire una classe Data per rappresentare una specifica data all'interno di un anno non bisestile.\n#STATO:\n- mappa_mesi: dizionario con chiave il numero del mese e valore il numero di giorni. Esempio: {1: 31, 2: 28, ...}. Sfruttare questa mappa per controllare la validità di una data e per calcolare la differenza tra due date.\n- giorno: intero con valore compreso tra 1 e il numero di giorni del mese. \n- mese: intero con valore compreso tra 1 e 12.\nOgni volta che si modifica una di queste variabili di istanza, devono essere controllati tipo e valori e sollevate opportune eccezioni ValueError o TypeError se i parametri non sono validi.\n\n#METODI:\n- Costruttore che prende in input giorno, mese e anno e inizializza le variabili di istanza. Esempio di utilizzo: d = Data(1, 1) FATTO\n- Metodi getter e setter per giorno e mese. FATTO\n- Metodo per la rappresentazione in forma di stringa della data, rispettando il formato di esempio: \"1/1\"\n- Metodo per il calcolo della differenza in giorni tra due date. Esempio di utilizzo: d2 - d1 dove d1 = Data(1, 1), d2 = Data(1, 2), risultato -> 31. Nota, d2 - d1 deve essere uguale a d1 - d2.\n- Metodo per il confronto di uguaglianza tra due date.\n- Metodo per il confronto di maggiore tra due date. Esempio di utilizzo: d1 < d2\n- Metodo per il confronto di minore tra due date. Esempio di utilizzo: d1 > d2\n- Metodo per il confronto di minore o uguale tra due date. Esempio di utilizzo: d1 <= d2\n\"\"\"\n#chiedere perchè se il costruttore prende in input giorno, mese e anno, ma poi si inizializzano solo giorno e mese e non l'anno\n#dire se va bene il controllo del giorno e mese nel costruttore o se va fatto in un metodo setter\nclass Data:\n    mappa_mesi = {1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31} #2025 anno di riferimento non bisestile\n\n    def __init__(self, giorno:int, mese:int, anno:int=2025):\n        self._mese = None\n        self.anno = anno\n        self.set_mese(mese)\n        self.set_giorno(giorno)\n\n    #metodi getter e setter per giorno e mese\n    def get_giorno(self): \n        return self._giorno\n    \n    def set_giorno(self, valore):\n        #controllo che il giorno è un numero intero\n        if not isinstance(valore, int):\n            raise TypeError(\"Il giorno deve restituire un numero intero\")\n        #controllo che il valore del giorno sia compreso tra 1 e il numero di giorni del mese\n        if valore < 1 or valore > self.mappa_mesi.get(self._mese, 31):\n            raise ValueError(f\"Giorno non valido per il mese {self._mese}\")\n        self._giorno = valore\n\n    def get_mese(self):\n        return self._mese\n    \n    def set_mese(self, valore):\n        #controllo che il mese sia un intero\n        if not isinstance(valore, int):\n            raise TypeError(\"Il mese deve restituire un numero intero\")\n        if valore < 1 or valore > 12:\n            raise ValueError(\"Il mese deve essere compreso tra 1 e 12\")\n        self._mese = valore\n\n    #metodo per la rappresentazione in forma di stringa della data\n    def __str__(self):\n        return f\"{self._giorno}/{self._mese}/{self.anno}\"\n    \n    #metodo per il calcolo della differenza in giorni tra due date\n    def __sub__(self, other):\n        if not isinstance(other, Data):\n            raise TypeError(\"Operazione non consentita tra oggetti di tipo diverso\")\n        # Calcola il numero totale di giorni dall'inizio dell'anno per ciascuna data\n        giorni_self = sum(self.mappa_mesi[m] for m in range(1, self._mese)) + self._giorno # generator expression per sommare i giorni di tutti i mesi precedenti riferiti alla data self (d1)\n        giorni_other = sum(self.mappa_mesi[m] for m in range(1, other._mese)) + other._giorno # generator expression per sommare i giorni di tutti i mesi precedenti riferiti alla data other (d2)\n        # Calcola la differenza in valore assoluto tra i due numeri di giorni\n        return abs(giorni_self - giorni_other) # ritorna il valore assoluto della differenza tra i due numeri di giorni\n    \n    #metodo per il confronto di uguaglianza tra due date\n    def __eq__(self, other):\n        if not isinstance(other, Data):\n            raise TypeError(\"Operazione non consentita tra oggetti di tipo diverso\")\n        return self._giorno == other._giorno and self._mese == other._mese # ritorna un valore booleano\n    \n    #metodo per il confronto di maggiore tra due date\n    def __lt__(self, other):\n        if not isinstance(other, Data):\n            raise TypeError(\"Operazione non consentita tra oggetti di tipo diverso\")\n        return (self._mese, self._giorno) < (other._mese, other._giorno) # ritorna un valore booleano\n    \n    #metodo per il confronto di min\n    def __gt__(self, other):\n        if not isinstance(other, Data):\n            raise TypeError(\"Operazione non consentita tra oggetti di tipo diverso\")\n        return (self._mese, self._giorno) > (other._mese, other._giorno) # ritorna un valore booleano\n    \n    #metodo per il confronto di minore o uguale tra due date\n    def __le__(self, other):\n        if not isinstance(other, Data):\n            raise TypeError(\"Operazione non consentita tra oggetti di tipo diverso\")\n        return (self._mese, self._giorno) >= (other._mese, other._giorno) # ritorna un valore booleano\n    \n\"\"\"\nDefinire una classe Prenotazione per rappresentare una prenotazione di una stanza di un hotel.\nLe pronotazioni saranno solo all'interno dello stesso anno solare. Ad esempio, non è possibile avere come data di arrivo il 27/12 e come data di partenza il 5/1.\n#STATO:\n- id_prenotazione: intero non negativo.\n- numero_stanza: intero positivo.\n- data_arrivo: oggetto di tipo Data.\n- data_partenza: oggetto di tipo Data, non deve essere precedente alla data di arrivo.\n- nome_cliente: stringa non vuota.\n- numero_persone: intero positivo.\nOgni volta che si modifica una di queste variabili di istanza, devono essere controllati tipo e valori e sollevate opportune eccezioni ValueError o TypeError se i parametri non sono validi.\n\n#METODI:\n- Costruttore che prende in input il numero della stanza, la data di arrivo, la data di partenza, il nome del cliente e il numero di persone. Esempio di utilizzo: p = Prenotazione(101, Data(1, 1), Data(5, 1), \"Mario Rossi\", 2)\n- Metodi getter e setter per il numero della stanza, la data di arrivo, la data di partenza, il nome del cliente e il numero di persone.\n- Metodo per la rappresentazione in forma di stringa della prenotazione. Rispettando il formato di esempio: \"Prenotazione 1 per stanza 101 da 1/1 a 5/1 a nome Mario Rossi per 1 persone\"\n- Metodo per il confronto di uguaglianza profonda tra due prenotazioni.\n\"\"\"\n#cercare i metodi per il confronto di uguaglianza profonda o no\nclass Prenotazione:\n    id_counter = 1\n\n    def __init__(self, id_prenotazione=None, numero_stanza=0, data_arrivo=None, data_partenza=None, nome_cliente=\"\", numero_persone=0):\n        if id_prenotazione is None:\n            self.id_prenotazione = Prenotazione.id_counter\n            Prenotazione.id_counter += 1\n        else:\n            if not isinstance(id_prenotazione, int) or id_prenotazione < 0:\n                raise ValueError(\"L'ID della prenotazione deve essere un intero non negativo.\")\n            self.id_prenotazione = id_prenotazione\n\n        self.numero_stanza = numero_stanza\n        self.data_arrivo = data_arrivo\n        self.data_partenza = data_partenza\n        self.nome_cliente = nome_cliente\n        self.numero_persone = numero_persone\n\n    @property\n    def id_prenotazione(self):\n        return self._id_prenotazione\n\n    @id_prenotazione.setter\n    def id_prenotazione(self, value):\n        if not isinstance(value, int):\n            raise TypeError(\"L'ID della prenotazione deve essere un intero.\")\n        if value < 0:\n            raise ValueError(\"L'ID della prenotazione deve essere un intero non negativo.\")\n        self._id_prenotazione = value\n\n    @property\n    def numero_stanza(self):\n        return self._numero_stanza\n\n    @numero_stanza.setter\n    def numero_stanza(self, value):\n        if not isinstance(value, int):\n            raise TypeError(\"Il numero della stanza deve essere un intero.\")\n        if value <= 0:\n            raise ValueError(\"Il numero della stanza deve essere un intero positivo.\")\n        self._numero_stanza = value\n\n    @property\n    def data_arrivo(self):\n        return self._data_arrivo\n\n    @data_arrivo.setter\n    def data_arrivo(self, value):\n        if not isinstance(value, Data):\n            raise TypeError(\"La data di arrivo deve essere un oggetto di tipo Data.\")\n        self._data_arrivo = value\n\n    @property\n    def data_partenza(self):\n        return self._data_partenza\n\n    @data_partenza.setter\n    def data_partenza(self, value):\n        if not isinstance(value, Data):\n            raise TypeError(\"La data di partenza deve essere un oggetto di tipo Data.\")\n        if value < self.data_arrivo:\n            raise ValueError(\"La data di partenza non può essere precedente alla data di arrivo.\")\n        if value.anno != self.data_arrivo.anno:\n            raise ValueError(\"Le prenotazioni devono essere all'interno dello stesso anno solare.\")\n        self._data_partenza = value\n\n    @property\n    def nome_cliente(self):\n        return self._nome_cliente\n\n    @nome_cliente.setter\n    def nome_cliente(self, value):\n        if not isinstance(value, str):\n            raise TypeError(\"Il nome del cliente deve essere una stringa.\")\n        if not value.strip():\n            raise ValueError(\"Il nome del cliente deve essere una stringa non vuota.\")\n        self._nome_cliente = value\n\n    @property\n    def numero_persone(self):\n        return self._numero_persone\n\n    @numero_persone.setter\n    def numero_persone(self, value):\n        if not isinstance(value, int):\n            raise TypeError(\"Il numero di persone deve essere un intero.\")\n        if value <= 0:\n            raise ValueError(\"Il numero di persone deve essere un intero positivo.\")\n        self._numero_persone = value\n\n    def __str__(self):\n        persone_str = \"persona\" if self.numero_persone == 1 else \"persone\"\n        return f\"Prenotazione {self.id_prenotazione} per stanza {self.numero_stanza} da {self.data_arrivo.get_giorno()}/{self.data_arrivo.get_mese()} a {self.data_partenza.get_giorno()}/{self.data_partenza.get_mese()} a nome {self.nome_cliente} per {self.numero_persone} {persone_str}\"\n\n    def __eq__(self, other):\n        if not isinstance(other, Prenotazione):\n            return False\n        return (\n            self.numero_stanza == other.numero_stanza and\n            self.data_arrivo == other.data_arrivo and\n            self.data_partenza == other.data_partenza and\n            self.nome_cliente == other.nome_cliente and\n            self.numero_persone == other.numero_persone\n        )\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/classi.py b/classi.py
--- a/classi.py	(revision 13001318b67badd3fa753e4ca9561cce0f3c607b)
+++ b/classi.py	(date 1742387319522)
@@ -22,7 +22,7 @@
     mappa_mesi = {1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31} #2025 anno di riferimento non bisestile
 
     def __init__(self, giorno:int, mese:int, anno:int=2025):
-        self._mese = None
+        self._mese = None       #todo questa è fatta ad hoc per il test, non so se va fatto cosi o se deve essere fatto piu generico, dovremmo chiedere o dimmi tu
         self.anno = anno
         self.set_mese(mese)
         self.set_giorno(giorno)
@@ -34,7 +34,7 @@
     def set_giorno(self, valore):
         #controllo che il giorno è un numero intero
         if not isinstance(valore, int):
-            raise TypeError("Il giorno deve restituire un numero intero")
+            raise TypeError("Il giorno deve restituire un numero intero")       #TODO viene usato un sacco di volte questo controllo quindi potremmo fare un metodo da chiamare cosi da evitare ridondanza, magari aggiungiamo una flag per il caso in cui deve essere anche maggiore di 0
         #controllo che il valore del giorno sia compreso tra 1 e il numero di giorni del mese
         if valore < 1 or valore > self.mappa_mesi.get(self._mese, 31):
             raise ValueError(f"Giorno non valido per il mese {self._mese}")
@@ -68,7 +68,7 @@
     #metodo per il confronto di uguaglianza tra due date
     def __eq__(self, other):
         if not isinstance(other, Data):
-            raise TypeError("Operazione non consentita tra oggetti di tipo diverso")
+            raise TypeError("Operazione non consentita tra oggetti di tipo diverso") #todo discorso uguale a prima, facciamo una funzione che ci chiama questo errore per ridurre ridondanza
         return self._giorno == other._giorno and self._mese == other._mese # ritorna un valore booleano
     
     #metodo per il confronto di maggiore tra due date
@@ -88,7 +88,7 @@
         if not isinstance(other, Data):
             raise TypeError("Operazione non consentita tra oggetti di tipo diverso")
         return (self._mese, self._giorno) >= (other._mese, other._giorno) # ritorna un valore booleano
-    
+    #TODO qua non dovrebbbe essere <= invece di >=?
 """
 Definire una classe Prenotazione per rappresentare una prenotazione di una stanza di un hotel.
 Le pronotazioni saranno solo all'interno dello stesso anno solare. Ad esempio, non è possibile avere come data di arrivo il 27/12 e come data di partenza il 5/1.
@@ -114,7 +114,7 @@
     def __init__(self, id_prenotazione=None, numero_stanza=0, data_arrivo=None, data_partenza=None, nome_cliente="", numero_persone=0):
         if id_prenotazione is None:
             self.id_prenotazione = Prenotazione.id_counter
-            Prenotazione.id_counter += 1
+            Prenotazione.id_counter += 1    # qua non dovremmo andare a vedere l' id della prenotazione ultimo che abbiamo nel file e partire da li?
         else:
             if not isinstance(id_prenotazione, int) or id_prenotazione < 0:
                 raise ValueError("L'ID della prenotazione deve essere un intero non negativo.")
